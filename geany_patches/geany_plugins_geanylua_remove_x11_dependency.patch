From b061ff8aa1ef04402905339ad655043564d07207 Mon Sep 17 00:00:00 2001
From: xiota <github@mentalfossa.com>
Date: Sun, 5 Mar 2023 17:53:10 -0800
Subject: [PATCH 1/2] GeanyLua: Fix geany.keygrab * Make platform agnostic *
 Fix infinite loop * Update documentation

---
 geanylua/docs/geanylua-ref.html |  57 +++++-----
 geanylua/glspi_app.c            | 188 +++++++++-----------------------
 2 files changed, 78 insertions(+), 167 deletions(-)

diff --git a/geanylua/glspi_app.c b/geanylua/glspi_app.c
index 14d2e780..e5a7b48c 100644
--- a/geanylua/glspi_app.c
+++ b/geanylua/glspi_app.c
@@ -439,170 +439,82 @@ static gint glspi_launch(lua_State* L)
 }
 
 
-static guint My_Shift_L=0;
-static guint My_Shift_R=0;
-static guint My_Control_L=0;
-static guint My_Control_R=0;
-static guint My_Alt_L=0;
-static guint My_Alt_R=0;
-
-
-#ifndef G_OS_WIN32
-
-#include <X11/Xlib.h>
-#include <X11/keysym.h>
-
-
-#define IsShift ( (My_Shift_L == ev->xkey.keycode) || (My_Shift_R == ev->xkey.keycode) )
-
-#define IsCtrl ( (My_Control_L == ev->xkey.keycode) || (My_Control_R == ev->xkey.keycode) )
-#define IsAlt ( (My_Alt_L == ev->xkey.keycode) || (My_Alt_R == ev->xkey.keycode) )
-
-#define IsCtrlAlt ( IsCtrl || IsAlt )
-
 typedef struct _KeyGrabData {
-gchar *prompt;
-GdkKeymapKey km;
+	gboolean keypress;
+	guint keyval;
 } _KeyGrabData;
 
 
-static GdkFilterReturn keygrab_cb(GdkXEvent *xevent, GdkEvent *event, gpointer data)
+static gboolean keygrab_cb(GtkWidget *widget, GdkEventKey *ev, gpointer data)
 {
-	XEvent*ev = (XEvent*) xevent;
-	GdkKeymapKey *km = (GdkKeymapKey*) data;
-	switch (ev->type) {
-		case KeyPress:{
-			if (IsShift) {
-				km->level=1;
-			} else {
-				if (!IsCtrlAlt) km->group=1; /* Flag to know we have keydown before keyup */
-			}
-			return GDK_FILTER_REMOVE;
-		}
-		case KeyRelease:{
-			if (IsShift) {
-				km->level=0;
-			} else {
-				if ((km->group==1)&&(!IsCtrlAlt)) { /* OK, we already got our keydown  */
-					km->group=2;
-					km->level=(ev->xkey.state & ShiftMask)?1:0;
-					km->keycode=ev->xkey.keycode;
-				}
-			}
-			return GDK_FILTER_REMOVE;
-		}
-		default:{}
-	}
-	return GDK_FILTER_CONTINUE;
-}
+	_KeyGrabData *km = (_KeyGrabData*) data;
 
-#define dosleep() g_usleep(1)
+	if (ev->keyval == 0) {
+		return FALSE;
+	}
 
-#else
-#include <windows.h>
-#define dosleep() Sleep(1)
+	km->keyval = ev->keyval;
+	km->keypress = TRUE;
+	return TRUE;
+}
 
-#define IsShift ( (My_Shift_L == msg->wParam) || (My_Shift_R == msg->wParam) )
 
-#define IsCtrl ( (My_Control_L == msg->wParam) || (My_Control_R == msg->wParam) )
-#define IsAlt ( (My_Alt_L == msg->wParam) || (My_Alt_R == msg->wParam) )
+static gint glspi_keygrab(lua_State* L)
+{
+	GeanyDocument *doc = NULL;
+	const gchar *prompt = NULL;
+	static gulong keygrab_cb_handle = 0;
 
-#define IsCtrlAlt ( IsCtrl || IsAlt )
 
+	_KeyGrabData km;
+	km.keypress = FALSE;
+	km.keyval = 0;
 
-static GdkFilterReturn keygrab_cb(GdkXEvent *xevent, GdkEvent *event, gpointer data)
-{
-	MSG*msg = (MSG*) xevent;
-	GdkKeymapKey *km = (GdkKeymapKey*) data;
-	switch (msg->message) {
-		case WM_KEYDOWN:{
-			if (IsShift) {
-				km->level=1;
-			} else {
-				if (!IsCtrlAlt) km->group=1; /* Flag to know we have keydown before keyup */
-			}
-			return GDK_FILTER_REMOVE;
-		}
-		case WM_KEYUP:{
-			if (IsShift) {
-				km->level=0;
-			} else {
-				if ((km->group==1)&&(!IsCtrlAlt)) { /* OK, we already got our keydown  */
-					km->group=2;
-					km->level=HIBYTE(GetKeyState(VK_SHIFT))?1:0;
-					km->keycode=msg->wParam;
-				}
-			}
-			return GDK_FILTER_REMOVE;
+	/* get prompt, if exists */
+	if (lua_gettop(L) > 0) {
+		if (!lua_isstring(L, 1)) {
+			return FAIL_STRING_ARG(1);
 		}
-		default:{}
+		prompt = lua_tostring(L,1);
+		doc = document_get_current();
 	}
-	return GDK_FILTER_CONTINUE;
-}
-
 
-#endif
-
-
-#include <gdk/gdkkeysyms.h>
-static gint init_key(guint keyval){
-	GdkKeymapKey *kmk=NULL;
-	GdkKeymap *gdk_key_map=gdk_keymap_get_default();
-	gint n_keys=0;
-	gint rv=0;
-	if (gdk_keymap_get_entries_for_keyval(gdk_key_map,keyval,&kmk,&n_keys)) {
-		rv=kmk[0].keycode;
-		g_free(kmk);
+	/* show prompt in tooltip */
+	if (prompt && doc && doc->is_valid ) {
+		gint fvl = scintilla_send_message(doc->editor->sci, SCI_GETFIRSTVISIBLELINE, 0, 0);
+		gint pos = sci_get_position_from_line(doc->editor->sci, fvl+1);
+		scintilla_send_message(doc->editor->sci, SCI_CALLTIPSHOW, pos+3, (sptr_t) prompt);
 	}
-	return rv;
-}
-
-#define InitKey(code,value) if (!code) { code=init_key(value); }
 
-static gint glspi_keygrab(lua_State* L)
-{
-	GeanyDocument*doc=NULL;
-	const gchar*prompt=NULL;
-	GdkKeymapKey km={0,0,0};
-	GdkKeymap *gdk_key_map;
-	km.keycode=0;
-	km.group=0; /* Note: we hijack this field to use as a flag for first keydown. */
-	km.level=0;
-	InitKey(My_Shift_L, GDK_Shift_L);
-	InitKey(My_Shift_R, GDK_Shift_R);
-	InitKey(My_Control_L, GDK_Control_L);
-	InitKey(My_Control_R, GDK_Control_R);
-	InitKey(My_Alt_L, GDK_Alt_L);
-	InitKey(My_Alt_R, GDK_Alt_R);
-	if (lua_gettop(L)>0) {
-		if (!lua_isstring(L,1)) {return FAIL_STRING_ARG(1); }
-		prompt=lua_tostring(L,1);
-		doc=document_get_current();
+	/* callback to handle keypress
+		only one keygrab callback can be running at a time, otherwise geanylua will hang
+	*/
+	if (!keygrab_cb_handle) {
+		keygrab_cb_handle = g_signal_connect(main_widgets->window, "key-press-event", G_CALLBACK(keygrab_cb), &km);
+	} else {
+		lua_pushnil(L);
+		return 1;
 	}
 
-	if (prompt && doc && doc->is_valid ) {
-		gint fvl=scintilla_send_message(doc->editor->sci,SCI_GETFIRSTVISIBLELINE, 0,0);
-		gint pos=sci_get_position_from_line(doc->editor->sci, fvl+1);
-		scintilla_send_message(doc->editor->sci,SCI_CALLTIPSHOW,pos+3, (sptr_t)prompt);
-	}
-	gdk_window_add_filter(gtk_widget_get_window(main_widgets->window), keygrab_cb, &km);
-	do {
+	/* wait for keypress */
+	while (!km.keypress) {
 		while (gtk_events_pending()) {
-			if (km.group==2) { break; }
+			if (km.keypress) {
+				break;
+			}
 			gtk_main_iteration();
 		}
-		if (km.group==2) { break; }
-		dosleep();
-	} while (km.group!=2);
+	}
+
+	/* clear callback */
+	g_clear_signal_handler(&keygrab_cb_handle, main_widgets->window);
 
-	gdk_window_remove_filter(gtk_widget_get_window(main_widgets->window), keygrab_cb, &km);
+	/* clear tooltip */
 	if (prompt && doc && doc->is_valid) {
-	sci_send_command(doc->editor->sci, SCI_CALLTIPCANCEL);
+		sci_send_command(doc->editor->sci, SCI_CALLTIPCANCEL);
 	}
-	km.group=0; /* reset the hijacked flag before passing to GDK */
-	gdk_key_map = gdk_keymap_get_default();
-	lua_pushstring(L, gdk_keyval_name(gdk_keymap_lookup_key(gdk_key_map, &km)));
 
+	lua_pushstring(L, gdk_keyval_name(km.keyval));
 	return 1;
 }
 
-- 
2.37.5


From 3c2e16a9d5834b1f153a2557ac819386481a9c2e Mon Sep 17 00:00:00 2001
From: xiota <github@mentalfossa.com>
Date: Sun, 5 Mar 2023 18:13:57 -0800
Subject: [PATCH 2/2] Use g_signal_handler_disconnect instead of
 g_clear_signal_handler

---
 geanylua/glspi_app.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/geanylua/glspi_app.c b/geanylua/glspi_app.c
index e5a7b48c..d21f8ba6 100644
--- a/geanylua/glspi_app.c
+++ b/geanylua/glspi_app.c
@@ -506,8 +506,9 @@ static gint glspi_keygrab(lua_State* L)
 		}
 	}
 
-	/* clear callback */
-	g_clear_signal_handler(&keygrab_cb_handle, main_widgets->window);
+	/* remove callback and clear handle */
+	g_signal_handler_disconnect(main_widgets->window, keygrab_cb_handle);
+	keygrab_cb_handle = 0;
 
 	/* clear tooltip */
 	if (prompt && doc && doc->is_valid) {
-- 
2.37.5

